#!/usr/bin/env python3
"""
PyBullet Robotics Simulation Environment

This module provides a complete robotics simulation environment using PyBullet
for executing robot tasks generated by the LLM interpretation system.

Features:
- Robot arm simulation with realistic physics
- Object manipulation and grasping
- Task execution from structured task sequences
- Collision detection and workspace boundaries
- Recording and export of simulation results

Author: TANGRAM Team
License: MIT
"""

import pybullet as p
import pybullet_data
import numpy as np
import time
import logging
import json
from pathlib import Path
from typing import List, Dict, Any, Tuple, Optional, Union

from config import PYBULLET_CONFIG, SIMULATION_DIR
from src.tangram.utils.logging_utils import setup_logger, log_function_call
from src.tangram.utils.geometry_utils import compute_distance_3d, quaternion_to_rotation_matrix

logger = setup_logger(__name__)

class RoboticsSimulation:
    """
    Complete robotics simulation environment using PyBullet.
    
    Manages robot loading, object manipulation, task execution,
    and simulation recording for the TANGRAM pipeline.
    """
    
    def __init__(self, gui: bool = None, time_step: float = None):
        """
        Initialize simulation environment.
        
        Args:
            gui: Enable GUI visualization (None = use config default)
            time_step: Physics simulation time step (None = use config default)
        """
        self.gui = gui if gui is not None else PYBULLET_CONFIG["gui"]
        self.time_step = time_step if time_step is not None else PYBULLET_CONFIG["time_step"]
        
        # Simulation state
        self.physics_client = None
        self.robot_id = None
        self.plane_id = None
        self.objects = {}  # obj_id -> object info
        self.simulation_time = 0.0
        self.task_results = []
        
        # Robot state
        self.robot_joints = []
        self.end_effector_id = None
        self.gripper_joints = []
        
        # Workspace configuration
        self.workspace_bounds = PYBULLET_CONFIG["workspace_bounds"]
        
        logger.info(f"Initialized simulation with GUI={'ON' if self.gui else 'OFF'}")
    
    @log_function_call()
    def initialize_simulation(self) -> bool:
        """
        Initialize PyBullet physics simulation.
        
        Returns:
            True if initialization successful
        """
        try:
            # Connect to PyBullet
            if self.gui:
                self.physics_client = p.connect(p.GUI)
                # Configure GUI camera
                p.configureDebugVisualizer(p.COV_ENABLE_GUI, 1)
                p.resetDebugVisualizerCamera(
                    cameraDistance=2.0,
                    cameraYaw=45,
                    cameraPitch=-30,
                    cameraTargetPosition=[0, 0, 0.5]
                )
            else:
                self.physics_client = p.connect(p.DIRECT)
            
            # Add PyBullet data path for built-in models
            p.setAdditionalSearchPath(pybullet_data.getDataPath())
            
            # Set physics parameters
            p.setGravity(0, 0, PYBULLET_CONFIG["gravity"])
            p.setTimeStep(self.time_step)
            p.setRealTimeSimulation(0)  # Step simulation manually
            
            # Load ground plane
            self.plane_id = p.loadURDF("plane.urdf")
            
            # Add table surface
            self._create_table()
            
            logger.info("PyBullet simulation initialized successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to initialize simulation: {e}")
            return False
    
    def _create_table(self) -> int:
        """Create a table surface for object manipulation."""
        table_height = 0.6
        table_size = [0.8, 0.8, 0.05]
        
        # Create table collision shape
        table_collision = p.createCollisionShape(
            p.GEOM_BOX,
            halfExtents=table_size
        )
        
        # Create table visual shape
        table_visual = p.createVisualShape(
            p.GEOM_BOX,
            halfExtents=table_size,
            rgbaColor=[0.6, 0.4, 0.2, 1.0]
        )
        
        # Create table body
        table_id = p.createMultiBody(
            baseMass=0,  # Static table
            baseCollisionShapeIndex=table_collision,
            baseVisualShapeIndex=table_visual,
            basePosition=[0, 0, table_height],
            baseOrientation=[0, 0, 0, 1]
        )
        
        self.objects[table_id] = {
            "name": "table",
            "type": "furniture",
            "position": [0, 0, table_height],
            "static": True
        }
        
        logger.info(f"Created table surface at height {table_height}m")
        return table_id
    
    @log_function_call()
    def load_robot(self, urdf_path: str = None, 
                   position: List[float] = None) -> bool:
        """
        Load robot arm into simulation.
        
        Args:
            urdf_path: Path to robot URDF file (None = use default)
            position: Robot base position (None = use default)
            
        Returns:
            True if robot loaded successfully
        """
        try:
            if urdf_path is None:
                # Use built-in Kuka robot as default
                urdf_path = "kuka_iiwa/model.urdf"
                
            if position is None:
                position = [0, 0, 0.65]  # On top of table
                
            # Load robot URDF
            self.robot_id = p.loadURDF(
                urdf_path,
                basePosition=position,
                baseOrientation=[0, 0, 0, 1],
                useFixedBase=True
            )
            
            # Get robot joint information
            self._analyze_robot_joints()
            
            # Set initial joint positions
            self._reset_robot_pose()
            
            logger.info(f"Loaded robot with {len(self.robot_joints)} joints")
            return True
            
        except Exception as e:
            logger.error(f"Failed to load robot: {e}")
            return False
    
    def _analyze_robot_joints(self):
        """Analyze robot joint structure and identify end effector."""
        if self.robot_id is None:
            return
            
        num_joints = p.getNumJoints(self.robot_id)
        self.robot_joints = []
        
        for i in range(num_joints):
            joint_info = p.getJointInfo(self.robot_id, i)
            joint_name = joint_info[1].decode('utf-8')
            joint_type = joint_info[2]
            
            # Store revolute and prismatic joints
            if joint_type in [p.JOINT_REVOLUTE, p.JOINT_PRISMATIC]:
                self.robot_joints.append({
                    'id': i,
                    'name': joint_name,
                    'type': joint_type,
                    'lower_limit': joint_info[8],
                    'upper_limit': joint_info[9],
                    'max_force': joint_info[10],
                    'max_velocity': joint_info[11]
                })
        
        # Set end effector as last joint
        if self.robot_joints:
            self.end_effector_id = self.robot_joints[-1]['id']
    
    def _reset_robot_pose(self):
        """Reset robot to home position."""
        if not self.robot_joints:
            return
            
        # Set joints to neutral positions
        for joint in self.robot_joints:
            joint_id = joint['id']
            # Use middle of joint range as neutral position
            lower = joint['lower_limit']
            upper = joint['upper_limit']
            
            if abs(lower) < 10 and abs(upper) < 10:  # Valid joint limits
                neutral_pos = (lower + upper) / 2
            else:
                neutral_pos = 0.0
                
            p.resetJointState(self.robot_id, joint_id, neutral_pos)
    
    @log_function_call()
    def add_scene_objects(self, object_positions: Dict[str, Any]) -> Dict[str, int]:
        """
        Add objects to simulation based on 3D scene reconstruction.
        
        Args:
            object_positions: Dictionary with object positions from 3D reconstruction
            
        Returns:
            Mapping from object IDs to PyBullet object IDs
        """
        object_mapping = {}
        
        try:
            for obj_id, obj_data in object_positions.items():
                position = obj_data["position"]
                class_name = obj_data["class_name"]
                
                # Adjust position to be above table
                position[2] = max(position[2], 0.7)  # Minimum height above table
                
                # Create object based on class
                pybullet_id = self._create_object_by_class(class_name, position)
                
                if pybullet_id is not None:
                    object_mapping[obj_id] = pybullet_id
                    self.objects[pybullet_id] = {
                        "name": f"{class_name}_{obj_id}",
                        "class": class_name,
                        "track_id": obj_id,
                        "position": position,
                        "static": False
                    }
                    
                    logger.info(f"Added {class_name} at position {position}")
            
            return object_mapping
            
        except Exception as e:
            logger.error(f"Failed to add scene objects: {e}")
            return {}
    
    def _create_object_by_class(self, class_name: str, 
                               position: List[float]) -> Optional[int]:
        """Create object based on its class name."""
        
        # Object templates
        object_configs = {
            "bottle": {"shape": "cylinder", "size": [0.03, 0.15], "color": [0.2, 0.8, 0.2, 1.0]},
            "cup": {"shape": "cylinder", "size": [0.04, 0.08], "color": [0.8, 0.8, 0.8, 1.0]},
            "bowl": {"shape": "cylinder", "size": [0.06, 0.03], "color": [0.8, 0.6, 0.4, 1.0]},
            "book": {"shape": "box", "size": [0.15, 0.2, 0.02], "color": [0.6, 0.3, 0.3, 1.0]},
            "phone": {"shape": "box", "size": [0.07, 0.14, 0.008], "color": [0.1, 0.1, 0.1, 1.0]},
            "apple": {"shape": "sphere", "size": [0.04], "color": [0.8, 0.2, 0.2, 1.0]},
        }
        
        config = object_configs.get(class_name, 
                                   {"shape": "box", "size": [0.05, 0.05, 0.05], 
                                    "color": [0.5, 0.5, 0.5, 1.0]})
        
        try:
            if config["shape"] == "box":
                collision_shape = p.createCollisionShape(p.GEOM_BOX, halfExtents=config["size"])
                visual_shape = p.createVisualShape(p.GEOM_BOX, halfExtents=config["size"], 
                                                 rgbaColor=config["color"])
            elif config["shape"] == "cylinder":
                radius, height = config["size"]
                collision_shape = p.createCollisionShape(p.GEOM_CYLINDER, radius=radius, height=height)
                visual_shape = p.createVisualShape(p.GEOM_CYLINDER, radius=radius, length=height,
                                                 rgbaColor=config["color"])
            elif config["shape"] == "sphere":
                radius = config["size"][0]
                collision_shape = p.createCollisionShape(p.GEOM_SPHERE, radius=radius)
                visual_shape = p.createVisualShape(p.GEOM_SPHERE, radius=radius,
                                                 rgbaColor=config["color"])
            else:
                return None
            
            # Create object with physics
            obj_id = p.createMultiBody(
                baseMass=0.1,  # Light objects
                baseCollisionShapeIndex=collision_shape,
                baseVisualShapeIndex=visual_shape,
                basePosition=position,
                baseOrientation=[0, 0, 0, 1]
            )
            
            return obj_id
            
        except Exception as e:
            logger.error(f"Failed to create object {class_name}: {e}")
            return None
    
    @log_function_call()
    def execute_task_sequence(self, task_sequence: List[Dict[str, Any]], 
                            object_mapping: Dict[str, int]) -> List[Dict[str, Any]]:
        """
        Execute sequence of robot tasks in simulation.
        
        Args:
            task_sequence: List of tasks from LLM interpretation
            object_mapping: Mapping from track IDs to PyBullet object IDs
            
        Returns:
            List of task execution results
        """
        self.task_results = []
        
        for task in task_sequence:
            logger.info(f"Executing task {task.get('id', '?')}: {task.get('description', 'Unknown')}")
            
            result = self._execute_single_task(task, object_mapping)
            self.task_results.append(result)
            
            # Small delay between tasks
            time.sleep(0.5)
        
        return self.task_results
    
    def _execute_single_task(self, task: Dict[str, Any], 
                           object_mapping: Dict[str, int]) -> Dict[str, Any]:
        """Execute a single robot task."""
        task_type = task.get("type", "unknown")
        task_id = task.get("id", -1)
        start_time = time.time()
        
        result = {
            "task_id": task_id,
            "type": task_type,
            "description": task.get("description", ""),
            "start_time": start_time,
            "success": False,
            "error": None,
            "duration": 0.0
        }
        
        try:
            if task_type == "move_to":
                success = self._execute_move_to(task)
            elif task_type == "pick":
                success = self._execute_pick(task, object_mapping)
            elif task_type == "place":
                success = self._execute_place(task)
            else:
                logger.warning(f"Unknown task type: {task_type}")
                success = False
            
            result["success"] = success
            
        except Exception as e:
            logger.error(f"Task {task_id} failed: {e}")
            result["error"] = str(e)
        
        result["duration"] = time.time() - start_time
        return result
    
    def _execute_move_to(self, task: Dict[str, Any]) -> bool:
        """Execute move_to task."""
        target_position = task.get("position", [0, 0, 0.8])
        
        if self.robot_id is None or self.end_effector_id is None:
            logger.error("Robot not loaded")
            return False
        
        # Use inverse kinematics to reach target position
        target_orientation = [0, 1, 0, 0]  # Pointing down
        
        joint_positions = p.calculateInverseKinematics(
            self.robot_id,
            self.end_effector_id,
            target_position,
            target_orientation
        )
        
        # Move joints to target position
        for i, joint in enumerate(self.robot_joints):
            if i < len(joint_positions):
                p.setJointMotorControl2(
                    self.robot_id,
                    joint['id'],
                    p.POSITION_CONTROL,
                    targetPosition=joint_positions[i],
                    maxVelocity=joint['max_velocity'] * 0.5
                )
        
        # Simulate movement
        for _ in range(100):  # Allow time for movement
            p.stepSimulation()
            if self.gui:
                time.sleep(self.time_step)
        
        # Check if reached target (approximately)
        current_pos = p.getLinkState(self.robot_id, self.end_effector_id)[0]
        distance = compute_distance_3d(current_pos, target_position)
        
        success = distance < 0.1  # 10cm tolerance
        logger.info(f"Move to {target_position}: {'SUCCESS' if success else 'FAILED'} "
                   f"(distance: {distance:.3f}m)")
        
        return success
    
    def _execute_pick(self, task: Dict[str, Any], 
                     object_mapping: Dict[str, int]) -> bool:
        """Execute pick task."""
        object_id = task.get("object_id")
        
        if not object_id or object_id not in object_mapping:
            logger.error(f"Object {object_id} not found in mapping")
            return False
        
        pybullet_obj_id = object_mapping[object_id]
        
        # Get object position
        obj_pos, obj_orn = p.getBasePositionAndOrientation(pybullet_obj_id)
        
        # Move above object
        approach_pos = [obj_pos[0], obj_pos[1], obj_pos[2] + 0.2]
        if not self._execute_move_to({"position": approach_pos}):
            return False
        
        # Move down to object
        grasp_pos = [obj_pos[0], obj_pos[1], obj_pos[2] + 0.05]
        if not self._execute_move_to({"position": grasp_pos}):
            return False
        
        # Simulate grasping by creating constraint
        constraint_id = p.createConstraint(
            self.robot_id, self.end_effector_id,
            pybullet_obj_id, -1,
            p.JOINT_FIXED,
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0.05]
        )
        
        # Store constraint for later release
        if not hasattr(self, 'grasped_objects'):
            self.grasped_objects = {}
        self.grasped_objects[object_id] = constraint_id
        
        # Move up with object
        lift_pos = [obj_pos[0], obj_pos[1], obj_pos[2] + 0.3]
        success = self._execute_move_to({"position": lift_pos})
        
        logger.info(f"Pick object {object_id}: {'SUCCESS' if success else 'FAILED'}")
        return success
    
    def _execute_place(self, task: Dict[str, Any]) -> bool:
        """Execute place task."""
        target_position = task.get("position", [0, 0, 0.7])
        object_id = task.get("object_id")
        
        if not object_id or not hasattr(self, 'grasped_objects') or object_id not in self.grasped_objects:
            logger.error(f"Object {object_id} not currently grasped")
            return False
        
        # Move to place position
        place_pos = [target_position[0], target_position[1], target_position[2] + 0.2]
        if not self._execute_move_to({"position": place_pos}):
            return False
        
        # Lower to place position
        final_pos = [target_position[0], target_position[1], target_position[2] + 0.05]
        if not self._execute_move_to({"position": final_pos}):
            return False
        
        # Release object by removing constraint
        constraint_id = self.grasped_objects[object_id]
        p.removeConstraint(constraint_id)
        del self.grasped_objects[object_id]
        
        # Move away
        retreat_pos = [target_position[0], target_position[1], target_position[2] + 0.3]
        success = self._execute_move_to({"position": retreat_pos})
        
        logger.info(f"Place object {object_id}: {'SUCCESS' if success else 'FAILED'}")
        return success
    
    def get_simulation_state(self) -> Dict[str, Any]:
        """Get current simulation state for analysis."""
        state = {
            "simulation_time": self.simulation_time,
            "robot_pose": None,
            "object_positions": {},
            "task_progress": len(self.task_results)
        }
        
        # Get robot end effector pose
        if self.robot_id and self.end_effector_id:
            link_state = p.getLinkState(self.robot_id, self.end_effector_id)
            state["robot_pose"] = {
                "position": list(link_state[0]),
                "orientation": list(link_state[1])
            }
        
        # Get object positions
        for obj_id, obj_info in self.objects.items():
            if not obj_info.get("static", False):
                pos, orn = p.getBasePositionAndOrientation(obj_id)
                state["object_positions"][obj_info["name"]] = {
                    "position": list(pos),
                    "orientation": list(orn)
                }
        
        return state
    
    @log_function_call()
    def save_simulation_results(self, output_file: str) -> bool:
        """Save simulation results and state to file."""
        try:
            results = {
                "simulation_config": PYBULLET_CONFIG,
                "task_results": self.task_results,
                "final_state": self.get_simulation_state(),
                "objects": {str(k): v for k, v in self.objects.items()},
                "total_simulation_time": self.simulation_time
            }
            
            output_path = Path(output_file)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            
            with open(output_path, 'w') as f:
                json.dump(results, f, indent=2)
            
            logger.info(f"Simulation results saved to {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to save simulation results: {e}")
            return False
    
    def cleanup(self):
        """Clean up simulation resources."""
        if self.physics_client is not None:
            p.disconnect()
            self.physics_client = None
            logger.info("Simulation cleanup completed")

def main():
    """Test the robotics simulation environment."""
    print("PyBullet Robotics Simulation Environment")
    
    # Create simulation
    sim = RoboticsSimulation(gui=True)
    
    try:
        # Initialize simulation
        if not sim.initialize_simulation():
            print("Failed to initialize simulation")
            return
        
        # Load robot
        if not sim.load_robot():
            print("Failed to load robot")
            return
        
        # Test with sample objects
        sample_objects = {
            "1": {"position": [0.3, 0.2, 0.7], "class_name": "bottle"},
            "2": {"position": [-0.2, 0.3, 0.7], "class_name": "cup"}
        }
        
        object_mapping = sim.add_scene_objects(sample_objects)
        
        # Test task sequence
        sample_tasks = [
            {
                "id": 0,
                "type": "move_to",
                "position": [0.3, 0.2, 0.9],
                "description": "Move to bottle"
            },
            {
                "id": 1,
                "type": "pick",
                "object_id": "1",
                "description": "Pick up bottle"
            },
            {
                "id": 2,
                "type": "place",
                "object_id": "1",
                "position": [-0.4, -0.3, 0.7],
                "description": "Place bottle in storage"
            }
        ]
        
        # Execute tasks
        results = sim.execute_task_sequence(sample_tasks, object_mapping)
        
        # Save results
        output_file = SIMULATION_DIR / "test_simulation_results.json"
        sim.save_simulation_results(output_file)
        
        print(f"Simulation completed. {len([r for r in results if r['success']])} / {len(results)} tasks successful")
        
        # Keep simulation running for observation
        if sim.gui:
            input("Press Enter to exit simulation...")
        
    finally:
        sim.cleanup()

if __name__ == "__main__":
    main()